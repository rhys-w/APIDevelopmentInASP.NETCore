How Does HTTP Work?

Request sent, containing:
- verb, the action to take 	e.g. POST
- headers, information about the request
- content, optionally asked for

Example:
VERB		POST
HEADERS		Content Length: 11
CONTENT		Hello World

Get a response back, containing:
- status code
- headers
- content

Example:
STATUS CODE	201
HEADERS		Content Type: text
CONTENT 	Hello World

The Server:
- Stateless
- This enables scaling

Requests:
GET:	Request Resource
POST:	Create Resource
PUT:	Update Resource
PATCH:  Update Partial Resource e.g. Part X of resource Y
DELETE: Delete Resource
(there are more)

Headers:
- Metadata
- Name value pairs

Header examples:
- Content Type: The format of content
- Content Length: Size of content
- Auth: Who is making the call
- Accept: What type(s) can accept
(there are lots more)

Content Concerning Request:
- HTML, CSS, JavaSript, XML, JSON
- Content is not valid with some verbs
- Information to help fulfill request
- Binary and blobs common (e.g. .jpg)

Response Codes:
- 100-199: Informational
- 200-299: Success
- 300-399: Redirection
- 400-499: Client Errors
- 500-599: Server Errors

What is REST?
- REpresentational State Transfer
- Separation of Client and Server
- Server Requests are Stateless
- Cacheable Requests
- Uniform Interface


API DESIGN:

Api Design
- Nouns are Good, Verbs are Bad
- Prefer Nouns e.g. customers, invoivces, products, employees
- Nouns contain resources 
- Prefer plurals e.g. customers not customer.

Resources (What are they?):
- People, Invoices, Products
- Nouns you want to expose through the API
- A resource can be a complex object within a given context
	(Not necessarily just one entity)

Identifiers in URI's
- Use unique identifiers
- Does not have to be 'primary keys'

Query Strings
- Use for non-resource properties
	e.g. sorts, pages, formats


Verbs and URI's

How do I do Verbs then?

Resource: Customers

/customers
Get: Get List
Post: New Customer
Put: Update Batch (rare)
Delete: Error

/customers/123
Get: Get Item
Post: Error
Put: Update Item
Delete: Delete Item

Idempotency
- Operations result in same side effect
- Get should return the same data, assuming no data has changed
- Put should make the changes if needed
- Patch should make the change if needed
- Delete should delete the resource if it exists
- EXCEPTION: Post is not idempotent

Hypermedia:
- An idea as part of what REST wants you to do
- Allows results to be self describing
- Allows programmatic navigation of API endpoints
- Adds complexity

Associations:

- Sub objects for existing API's
	- e.g. invoices for a customer 
		/api/customers/123/invoices
	- e.g. ratings for a specific game 
		/api/games/halo-3/ratings
	- e.g. payments related to a specific invoice
		/api/invoices/2003-01-24/payments

- Should return lists with the same shape, in different scopes
	/api/customers/123/invoices
	/api/invoices
	These both return a list of the same shape, just with different scopes

- Endpoints can have multiple associations
	/api/customers/123/invoices
	/api/customers/123/payments
	/api/customers/123/shipments

- Search should use queries
- Don't use associations to get things like...
	- 'all customers in a state'
		/api/customers?st=GA
	- 'all customers with sales id in state'
		/api/customers?st=GA&salesid=144

Paging:

- Lists should support paging
- Query strings are commonly used:
	/api/sites?page=1&page_size=25
- Use wrappers to imply paging:
	{
		totalResults: 255,
		nextPage: "api/sites?page=5"
		prevPage: "api/sites?page=3"
		results: [...]
	}

Error Handling:
- Use when it is useful for the user
- Use when it is NOT dangerous for security
	e.g. 'Username and password don't match' is dumb.
		A message that lets a hacker know they've hit a correct username makes their life easier

Caching:
Get
- Request: Get, Version=lat_xyz, Hello World
- Response: 304 Not Modified
- Lets the client ask the server if it has the latest version without getting and sending back.

Put
- For concurrency (letting multiple people use the system at once)
- Request: Put, If-Match=last_xyz, Hell World
- Checks if the last_xyz data is the same as what is on the server
- Make the change if it is
- If it isn't, someone else must have changed it since
- Response: 412 Precondition failed

Entity Tags (ETags)
- Strong and Weak Caching Support
- Strong - when things are not likely to change (in weeks)
- Weak - short lived, likely to change regularly

ETag Examples
- Weak: W/"12345"
- Strong: "12345"

GET Example
Request with If-None-Match...
Get:			/api/games/2
Accept:			application/json
Host:			localhost:8863
If-None-Match:	"12345"

Repsonse if not modified...
304 Not Modified

PUT/DELETE Example
Request with If-Match...
Put:			/api/games/2
Accept:			application/json
Host:			localhost:8863
If-Match:		"12345"

Response if modified...
412 Precondition Failed

Functional APIs:
- Should be the exception rather than the rule WHEN designing a REST API.
- If they regularly come up, look at whether you are developing a RPC layer
	instead of an API layer.

Async API's:
- Some APIs aren't RESTful in nature
- They need long-life, polling
- Non-REST solutions are useful

Async API Solutions to consider
- Comet
- gRPC
- SignalR
- Firebase
- Socket.IO

Versioning For Your API:

Should you version your API?
- Once you publish, it is set in stone.
- Users rely on the API.
- Decisions have to consider how to not break code users have written against your API.

Goal:
- Write an API that can evolve, without breaking clients.
- Needs to support both new and old.
- Planning and design upfront has prevented as much requirement for versioning as possible.

How:
- Prioritize clients. This should be easy for them, not you (if you have to choose).
- Versioning in the URI Path
	- Example: /api/v2/customers
	- Pro: Clear to clients which version they are using
	- Con: Tends to be brittle. Clients have to change API's to use.
- Versioning with the Query String
	- Example: /api/customers?v=2.0
	- Pro: Versioning is optionally included
	- Con: Too easy for clients to miss needing the version
- Versioning with Headers
	- Example:
		Get				/api/camps
		Host			lostlhost:44388
		Content-Type:	application/json
		X-Version:		2.0
	- Pro: Separates versioning from the rest of the API (Decoupled)
	- Con: Requires more sophisticated developer to manipulate headers